\documentclass[xetex,table]{beamer}

\usepackage[autostyle]{csquotes}
\usepackage{hyperref}
\usepackage{color}
\usepackage{setspace}
\usepackage{listings}
\usepackage{minted}

\usetheme{metropolis}

\usemintedstyle{perldoc}

\title{Build Automation:\\Introduzione a Make, Autotools e CMake}
\author{Luca Ceresoli\\
  \href{mailto:luca@lucaceresoli.net}{luca@lucaceresoli.net}\\
  \url{http://lucaceresoli.net}
}
\date{Linux Day 2017}

\begin{document}

\maketitle

\section{Introduzione}

\begin{frame}{Processo di build}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/c-example.pdf}

    \pause
    \vspace{0.1\textheight}
    \texttt{gcc -o hello hello.c utils.c}
  \end{center}
\end{frame}

\begin{frame}{Processo di build}
  \begin{flushright}
    \includegraphics[width=0.33\textwidth]{images/c-example.pdf}
  \end{flushright}

  Processo di build:
  \begin{itemize}
  \item Input: il lavoro di un umano
  \item Output: un programma, una libreria, un documento, \dots
  \end{itemize}

  Esempi:
  \begin{itemize}
  \item Codice C / C++ \textrightarrow{} un eseguibile o una libreria
  \item File di testo \textrightarrow{} Un documento PDF
  \end{itemize}
\end{frame}

\begin{frame}{Dove andrà il tuo software domani?}
  \begin{itemize}
  \item Continuous integration / continuous delivery
    \begin{itemize}
    \item Jenkins, Travis CI...
    \item Server locale o ``cloud''
    \end{itemize}
    \pause
  \item Distribuzioni: dpkg, rpm...
    \pause
  \item Sistemi embedded
    \begin{itemize}
    \item Buildroot
    \item Openembedded
    \item OpenWRT
    \end{itemize}
    \pause
  \item Windows, MacOS, Android, iOS
  \end{itemize}
\end{frame}

\begin{frame}{Come vuoi compilare il tuo software?}
  \begin{itemize}
  \item Debug / Release
  \item \texttt{-Wall -Werror}
  \item Librerie: shared / static
  \item \dots
  \end{itemize}
\end{frame}

\begin{frame}{Build automation: necessità}
  \begin{itemize}
  \item Da riga di comando
  \item Deve funzionare in ambienti diversi
  \item Non deve avere {\em policy} hard-coded
  \end{itemize}
\end{frame}

\section{Shell script}

\definecolor{codebackground}{rgb}{0.96,0.96,0.75}

\begin{frame}[fragile]{Shell script semplice}
  \begin{center}
  \includegraphics[height=0.4\textheight]{images/shell.pdf}
  \end{center}

  \texttt{build.sh}:

  \inputminted[bgcolor=codebackground,frame=single]{shell}{examples/1-shell-1/build.sh}
\end{frame}

\begin{frame}{Shell script semplice}
  \begin{itemize}
  \item[\checkmark] Funziona per casi molto semplici
  \item[$\times$]   Ricompila tutto ogni volta (se ci sono 100 file sorgente?)
  \end{itemize}
\end{frame}

\begin{frame}{File oggetto intermedi}
  \center\includegraphics[height=0.5\textheight]{images/depend-graph.pdf}
\end{frame}

\begin{frame}[fragile]{File oggetto intermedi}
  \small\inputminted[bgcolor=codebackground,frame=single]{shell}{examples/1-shell-2/build.sh}
\end{frame}

\begin{frame}{File oggetto intermedi}
  \begin{itemize}
  \item[\checkmark] Più efficiente
  \item[$\times$]   Scomodo da scrivere e mantenere
  \item[$\times$]   Non sfrutta CPU multi core
  \end{itemize}
\end{frame}

\section{Make}

\begin{frame}{Make}
  \center\includegraphics[width=0.8\textwidth]{images/makefile.pdf}
\end{frame}

\begin{frame}{Makefile}
  \texttt{Makefile} contiene {\em regole}:

  \inputminted[bgcolor=codebackground,frame=single]{makefile}{examples/2-make-1/Makefile}
\end{frame}

\begin{frame}[fragile]{Regole}
  \begin{minted}[autogobble]{makefile}
    hello: hello.o utils.o
            gcc -o hello hello.o utils.o
  \end{minted}

  \begin{itemize}
  \item \texttt{hello} = target
  \item \texttt{hello.o utils.o} = dipendenze
  \item \texttt{gcc \dots} = comandi
  \end{itemize}
\end{frame}

\begin{frame}{Grafo delle dipendenze}
  \center\includegraphics[height=0.4\textheight]{images/depend-graph.pdf}
\end{frame}

\begin{frame}[fragile]{Uso di Make}
  \begin{minted}[autogobble]{shell-session}
    $ ls -tr
    utils.h  utils.c  hello.c  Makefile
    $ make
    gcc -c hello.c
    gcc -c utils.c
    gcc -o hello hello.o utils.o
    $ ls -tr
    utils.h  utils.c  hello.c  Makefile  utils.o  hello.o  hello
    $ touch utils.c
    $ make
    gcc -c utils.c
    gcc -o hello hello.o utils.o
    $
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Altre regole utili}
  \begin{minted}[autogobble]{makefile}
    install:
        install -m 755 hello /usr/bin/

    clean:
        rm -f hello hello.o utils.o

    dist:
        tar czf hello.tar.gz utils.h utils.c hello.c Makefile
  \end{minted}
\end{frame}

\begin{frame}{Alcuni vantaggi di Make}
  \begin{itemize}
  \item Scrittura delle regole
    \begin{itemize}
    \item Wildcard (\texttt{\%.o: \%.c})
    \item Implicit rules: varie regole predefinite (C, C++, \dots)
    \item \dots
    \end{itemize}
  \item Utilizzo
    \begin{itemize}
    \item Build in parallelo (\texttt{make -j<N>})
    \item Build di un target specifico (\texttt{make utils.o})
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Cosa manca a Make}
  \begin{itemize}
  \item Ricerca di librerie
  \item Prefix (\texttt{/usr}, \texttt{/usr/bin}, \dots)
  \item Diverted installation (\texttt{DESTDIR})
  \item Out of tree build
  \item Cross-compilazione (possibile ma scomoda)
  \end{itemize}
\end{frame}

\section{Autotools}

\begin{frame}[fragile]
  \begin{center}
  \begin{verbatim}
    ./configure
    make
    sudo make install
  \end{verbatim}
  \end{center}
\end{frame}

\begin{frame}{Autotools: schema semplificato}
  \center\includegraphics[height=0.7\textheight]{images/autotools.pdf}
\end{frame}

\begin{frame}[fragile]{Autoconf}
  \begin{columns}
    \column{0.7\textwidth}
    \texttt{configure.ac}
    \inputminted[bgcolor=codebackground,frame=single]{shell}{examples/3-autotools-1/configure.ac}

    \begin{itemize}
    \item È uno script di shell
    \item Con l'aggiunta di macro \texttt{m4}
    \end{itemize}

    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{images/autotools-autoconf.pdf}
  \end{columns}
\end{frame}

\begin{frame}{Autoconf}
  \small

  \begin{columns}
    \column{0.7\textwidth}
    \texttt{configure.ac}
    \inputminted[bgcolor=codebackground,frame=single]{shell}{examples/3-autotools-2/configure.ac}

    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{images/autotools-config-files.pdf}
  \end{columns}

  \texttt{Makefile.in}
  \inputminted[bgcolor=codebackground,frame=single]{makefile}{examples/3-autotools-2/Makefile.in}
\end{frame}

\begin{frame}{Automake}
  \begin{flushright}
    \includegraphics[width=0.3\textwidth]{images/autotools-automake.pdf}
  \end{flushright}

  \texttt{Makefile.am}
  \inputminted[bgcolor=codebackground,frame=single]{makefile}{examples/3-autotools-3/Makefile.am}

  \begin{itemize}
  \item È un normale Makefile
  \item Con l'aggiunta di costrutti di \texttt{automake}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Automake: PSV e PLV}
  \texttt{Makefile.am} si compone di:

  \begin{itemize}
  \item \mintinline{makefile}{bin_PROGRAMS = hello}
    \begin{itemize}
    \item Product List Variable (PLV)
    \item Elenca i {\em prodotti} da generare
    \end{itemize}
  \end{itemize}

  \begin{itemize}
  \item \mintinline{makefile}{hello_SOURCES = hello.c utils.c utils.h}
    \begin{itemize}
    \item Product Source Variable (PSV)
    \item Elenca i {\em sorgenti} necessari per generare un prodotto
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Autotools}
  \center\includegraphics[height=0.7\textheight]{images/autotools.pdf}
\end{frame}

\begin{frame}{Autotools: vantaggi}
  \begin{itemize}

  \item Usato da moltissimi software
  \item Compatibilità con ogni sistema UNIX-like
  \item Moltissime macro già pronte
  \item Usano shell e Make
  \item Generano \texttt{Makefile}:
    \begin{itemize}
    \item Conformi agli standard UNIX
    \item Completi (\texttt{make install},
    \texttt{make clean},
    \texttt{make dist}, \dots)
    \end{itemize}

  \item Vedi slide ``Cosa manca a Make'':
    \begin{itemize}
    \item Ricerca di librerie
    \item Prefix (\texttt{--prefix=/usr})
    \item Diverted installation (\texttt{DESTDIR})
    \item Out of tree build
    \item Cross-compilazione con strumenti standard
    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}{Autotools: svantaggi}
  \begin{itemize}
  \item Praticamente inutilizzabili su sistemi non UNIX-like
  \item Usano shell e Make
  \item Complesso da imparare inizialmente
    \begin{itemize}
    \item È facile scrivere codice ``sbagliato'' se non è chiaro il
      come funzionano
    \end{itemize}
  \item \texttt{./configure} è lento (esecuzione sequenziale)
  \end{itemize}
\end{frame}

\end{document}
