\documentclass[xetex,table]{beamer}

\usepackage[autostyle]{csquotes}
\usepackage{hyperref}
\usepackage{color}
\usepackage{setspace}
\usepackage{listings}
\usepackage{minted}

\usetheme{metropolis}

\usemintedstyle{perldoc}

\title{Build Automation:\\Introduzione a Make, Autotools e CMake}
\author{Luca Ceresoli\\
  \href{mailto:luca@lucaceresoli.net}{luca@lucaceresoli.net}\\
  \url{http://lucaceresoli.net}
}
\date{Linux Day 2017}

\begin{document}

\maketitle

\section{Introduzione}

\begin{frame}{Processo di build}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/c-example.pdf}

    \pause
    \vspace{0.1\textheight}
    \texttt{gcc -o hello hello.c utils.c}
  \end{center}
\end{frame}

\begin{frame}{Processo di build}
  \begin{flushright}
    \includegraphics[width=0.33\textwidth]{images/c-example.pdf}
  \end{flushright}

  Processo di build:
  \begin{itemize}
  \item Input: il lavoro di un umano
  \item Output: un programma, una libreria, un documento, \dots
  \end{itemize}

  Esempi:
  \begin{itemize}
  \item Codice C / C++ \textrightarrow{} un eseguibile o una libreria
  \item File di testo \textrightarrow{} Un documento PDF
  \end{itemize}
\end{frame}

\begin{frame}{Dove andrà il tuo software domani?}
  \begin{itemize}
  \item Continuous integration / continuous delivery
    \begin{itemize}
    \item Jenkins, Travis CI...
    \item Server locale o ``cloud''
    \end{itemize}
    \pause
  \item Distribuzioni: dpkg, rpm...
    \pause
  \item Sistemi embedded
    \begin{itemize}
    \item Buildroot
    \item Openembedded
    \item OpenWRT
    \end{itemize}
    \pause
  \item Windows, MacOS, Android, iOS
  \end{itemize}
\end{frame}

\begin{frame}{Come vuoi compilare il tuo software?}
  \begin{itemize}
  \item Debug / Release
  \item \texttt{-Wall -Werror}
  \item Librerie: shared / static
  \item \dots
  \end{itemize}
\end{frame}

\begin{frame}{Build automation: necessità}
  \begin{itemize}
  \item Da riga di comando
  \item Deve funzionare in ambienti diversi
  \item Non deve avere {\em policy} hard-coded
  \end{itemize}
\end{frame}

\section{Shell script}

\definecolor{codebackground}{rgb}{0.96,0.96,0.75}

\begin{frame}[fragile]{Shell script semplice}
  \begin{center}
  \includegraphics[height=0.4\textheight]{images/shell.pdf}
  \end{center}

  \texttt{build.sh}:

  \inputminted[bgcolor=codebackground,frame=single]{shell}{examples/1-shell-1/build.sh}
\end{frame}

\begin{frame}{Shell script semplice}
  \begin{itemize}
  \item[\checkmark] Funziona per casi molto semplici
  \item[$\times$]   Ricompila tutto ogni volta (se ci sono 100 file sorgente?)
  \end{itemize}
\end{frame}

\begin{frame}{File oggetto intermedi}
  \center\includegraphics[height=0.5\textheight]{images/depend-graph.pdf}
\end{frame}

\begin{frame}[fragile]{File oggetto intermedi}
  \small\inputminted[bgcolor=codebackground,frame=single]{shell}{examples/1-shell-2/build.sh}
\end{frame}

\begin{frame}{File oggetto intermedi}
  \begin{itemize}
  \item[\checkmark] Più efficiente
  \item[$\times$]   Scomodo da scrivere e mantenere
  \item[$\times$]   Non sfrutta CPU multi core
  \end{itemize}
\end{frame}

\section{Make}

\begin{frame}{Make}
  \center\includegraphics[width=0.8\textwidth]{images/makefile.pdf}
\end{frame}

\begin{frame}{Makefile}
  \texttt{Makefile} contiene {\em regole}:

  \inputminted[bgcolor=codebackground,frame=single]{makefile}{examples/2-make-1/Makefile}
\end{frame}

\begin{frame}[fragile]{Regole}
  \begin{minted}[autogobble]{makefile}
    hello: hello.o utils.o
            gcc -o hello hello.o utils.o
  \end{minted}

  \begin{itemize}
  \item \texttt{hello} = target
  \item \texttt{hello.o utils.o} = dipendenze
  \item \texttt{gcc \dots} = comandi
  \end{itemize}
\end{frame}

\begin{frame}{Grafo delle dipendenze}
  \center\includegraphics[height=0.4\textheight]{images/depend-graph.pdf}
\end{frame}

\begin{frame}[fragile]{Uso di Make}
  \begin{minted}[autogobble]{shell-session}
    $ ls -tr
    utils.h  utils.c  hello.c  Makefile
    $ make
    gcc -c hello.c
    gcc -c utils.c
    gcc -o hello hello.o utils.o
    $ ls -tr
    utils.h  utils.c  hello.c  Makefile  utils.o  hello.o  hello
    $ touch utils.c
    $ make
    gcc -c utils.c
    gcc -o hello hello.o utils.o
    $
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Altre regole utili}
  \begin{minted}[autogobble]{makefile}
    install:
        install -m 755 hello /usr/bin/

    clean:
        rm -f hello hello.o utils.o

    dist:
        tar czf hello.tar.gz utils.h utils.c hello.c Makefile
  \end{minted}
\end{frame}

\begin{frame}{Alcuni vantaggi di Make}
  \begin{itemize}
  \item Scrittura delle regole
    \begin{itemize}
    \item Wildcard (\texttt{\%.o: \%.c})
    \item Implicit rules: varie regole predefinite (C, C++, \dots)
    \item \dots
    \end{itemize}
  \item Utilizzo
    \begin{itemize}
    \item Build in parallelo (\texttt{make -j<N>})
    \item Build di un target specifico (\texttt{make utils.o})
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Cosa manca a Make}
  \begin{itemize}
  \item Ricerca di librerie
  \item Prefix (\texttt{/usr}, \texttt{/usr/bin}, \dots)
  \item Diverted installation (\texttt{DESTDIR})
  \item Out of tree build
  \item Cross-compilazione (possibile ma scomoda)
  \end{itemize}
\end{frame}

\end{document}
